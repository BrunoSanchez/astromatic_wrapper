# Copyright 2015 Fred Moolekamp
# BSD 3-clause license
"""
Pipeline for Astromatic-Wrapper
"""
import os
import numpy as np
import subprocess
import copy
import logging
from six import string_types
from astropy.io import fits

from astromatic_wrapper import api
from astromatic_wrapper.utils import utils

logger = logging.getLogger('astromatic.pipeline')

class PipelineError(utils.AstromaticError):
    """
    Class for errors when running an AstrOmatic Pipeline
    """
    pass

class Pipeline(object):
    def __init__(self, temp_path, build_paths={}, log_path=None, pipeline_name=None,
            steps=[], nextid=0, create_paths=False, **kwargs):
        """
        Parameters
        ----------
        temp_path: str
            path to store temporary files
        build_paths: dict (optional)
            paths to astromatic builds
                * Not needed if the codes were installed system wide (ex. 'sex' runs SExtractor)
                * Keys are commands for astromatic packages ('sex', 'scamp', 'swarp', 'psfex')
                * Values are the paths to the build for the given key
        log_path: str (optional)
            path to save astromatic xml log files
        steps: list of `astromatic.pipeline.PipelineStep` (optional)
            If the user already as a list of steps to run they can be 
            set when the pipeline is initialized
        nexid: int (optional)
            Next number to use for a pipeline step id. The default is ``0``
        kwargs: dict
            Additional keyword arguments that might be used in a custom pipeline.
        """
        self.temp_path = temp_path
        self.build_paths = build_paths
        self.create_paths = create_paths
        self.name = pipeline_name
        self.steps = steps
        self.next_id = 0
        self.run_steps = None
        self.run_warnings = None
        self.run_step_idx = 0
        
        # Set additional keyword arguements
        for key, value in kwargs.items():
            setattr(self, key, value)
        
        # If the temp path doesn't exist, give the user the option to create it
        utils.check_path(self.temp_path, create_paths)
        
        # Set the time that the pipeline was created and create a directory
        # for log files
        self.log_path = log_path
        if log_path is not None:
            utils.check_path(self.log_path, create_paths)
    
    def run_sex(self, step_id, files, api_kwargs={}, frames=None):
        """
        Run SExtractor with a specified set of parameters.
        
        Parameters
        ----------
        step_id: str
            Unique identifier for the current step in the pipeline
        files: dict
            Dict of filenames for fits files to use in sextractor. Possible keys are:
                * image: filename of the fits image (required)
                * dqmask: filename of a bad mixel mask for the given image (optional)
                * wtmap: filename of a weight map for the given image (optional)
        kwargs: dict
            Keyword arguements to pass to ``atrotoyz.Astromatic.run`` or
            ``astrotoyz.Astromatic.run_sex_frames``
        frames: str (optional)
            Only run sextractor on a specific set of frames. This should either be an 
            integer string, or a string of csv's
        
        Returns
        -------
        result: dict
            Result of the astromatic code execution. This will minimally contain a ``status``
            key, that indicates ``success`` or ``error``. Additional keys:
            - error_msg: str
                If there is an error and the user is storing the output or exporting XML metadata,
                ``error_msg`` will contain the error message generated by the code
            - output: str
                If ``store_output==True`` the output of the program execution is
                stored in the ``output`` value.
            - warnings: str
                If the WRITE_XML parameter is ``True`` then a table of warnings detected
                in the code is returned
        """
        if 'code' not in api_kwargs:
            api_kwargs['code'] = 'SExtractor'
        if 'cmd' not in api_kwargs and 'SExtractor' in self.build_paths:
            api_kwargs['cmd'] = self.build_paths['SExtractor']
        if 'temp_path' not in api_kwargs:
            api_kwargs['temp_path'] = self.temp_path
        if 'config' not in api_kwargs:
            api_kwargs['config'] = {}
        if 'CATALOG_NAME' not in api_kwargs['config']:
            api_kwargs['config']['CATALOG_NAME'] = files['image'].replace('.fits', '.cat.fits')
        if 'FLAG_IMAGE' not in api_kwargs['config'] and 'dqmask' in files:
            api_kwargs['config']['FLAG_IMAGE'] = files['dqmask']
        if 'WEIGHT_IMAGE' not in api_kwargs['config'] and 'wtmap' in files:
            api_kwargs['config']['WEIGHT_IMAGE'] = files['wtmap']
        if self.log_path is not None:
            if 'WRITE_XML' not in api_kwargs['config']:
                api_kwargs['config']['WRITE_XML'] = 'Y'
            if 'XML_NAME' not in api_kwargs['config']:
                api_kwargs['config']['XML_NAME'] = os.path.join(self.log_path, 
                    '{0}.sex.log.xml'.format(step_id))
        sex = api.Astromatic(**api_kwargs)
        if frames is None:
            result = sex.run(files['image'])
        else:
            result = sex.run_frames(files['image'], 'SExtractor', frames, False)
        return result
    
    def run_scamp(self, step_id, catalogs, api_kwargs={}, save_catalog=None):
        """
        Run SCAMP with a specified set of parameters
        
        Parameters
        ----------
        step_id: str
            Unique identifier for the current step in the pipeline
        catalogs: list
            List of catalog names used to generate astrometric solution
        api_kwargs: dict
            Dictionary of keyword arguments used to run SCAMP
        save_catalog: str (optional)
            If ``save_catalog`` is specified, the reference catalog used to generate the
            solution will be save to the path ``save_catalog``.
        
        Returns
        -------
        result: dict
            Result of the astromatic code execution. This will minimally contain a ``status``
            key, that indicates ``success`` or ``error``. Additional keys:
            - error_msg: str
                If there is an error and the user is storing the output or exporting XML metadata,
                ``error_msg`` will contain the error message generated by the code
            - output: str
                If ``store_output==True`` the output of the program execution is
                stored in the ``output`` value.
            - warnings: str
                If the WRITE_XML parameter is ``True`` then a table of warnings detected
                in the code is returned
        """
        if 'code' not in api_kwargs:
            api_kwargs['code'] = 'SCAMP'
        if 'cmd' not in api_kwargs and 'SCAMP' in self.build_paths:
            api_kwargs['cmd'] = self.build_paths['SCAMP']
        if 'temp_path' not in api_kwargs:
            api_kwargs['temp_path'] = self.temp_path
        if 'config' not in api_kwargs:
            api_kwargs['config'] = {}
        if save_catalog is not None:
            api_kwargs['config']['SAVE_REFCATALOG'] = 'Y'
            api_kwargs['config']['REFOUT_CATPATH'] = save_catalog
        if self.log_path is not None:
            if 'WRITE_XML' not in api_kwargs['config']:
                api_kwargs['config']['WRITE_XML'] = 'Y'
            if 'XML_NAME' not in api_kwargs['config']:
                api_kwargs['config']['XML_NAME'] = os.path.join(self.log_path, 
                    '{0}.scamp.log.xml'.format(step_id))
        scamp = api.Astromatic(**api_kwargs)
        result = scamp.run(catalogs)
        return result
    
    def run_swarp(self, step_id, filenames, api_kwargs, frames=None):
        """
        Run SWARP with a specified set of parameters
        
        Parameters
        ----------
        step_id: str
            Unique identifier for the current step in the pipeline
        filenames: list
            List of filenames that are stacked together
        api_kwargs: dict
            Keyword arguments used to run SWARP
        frames: list (optional)
            Subset of frames to stack. Default value is ``None``, which stacks all of the
            image frames for each file
        
        Returns
        -------
        result: dict
            Result of the astromatic code execution. This will minimally contain a ``status``
            key, that indicates ``success`` or ``error``. Additional keys:
            - error_msg: str
                If there is an error and the user is storing the output or exporting XML metadata,
                ``error_msg`` will contain the error message generated by the code
            - output: str
                If ``store_output==True`` the output of the program execution is
                stored in the ``output`` value.
            - warnings: str
                If the WRITE_XML parameter is ``True`` then a table of warnings detected
                in the code is returned
        """
        if 'code' not in api_kwargs:
            api_kwargs['code'] = 'SWarp'
        if 'cmd' not in api_kwargs and 'SWARP' in self.build_paths:
            api_kwargs['cmd'] = self.build_paths['SWARP']
        if 'temp_path' not in api_kwargs:
            api_kwargs['temp_path'] = self.temp_path
        if 'config' not in api_kwargs:
            api_kwargs['config'] = {}
        if 'RESAMPLE_DIR' not in api_kwargs['config']:
            api_kwargs['config']['RESAMPLE_DIR'] = api_kwargs['temp_path']
        #if 'IMAGEOUT_NAME' not in api_kwargs['config']:
        #    raise PipelineError('Must include a name for the new stacked image')
        if self.log_path is not None:
            if 'WRITE_XML' not in api_kwargs['config']:
                api_kwargs['config']['WRITE_XML'] = 'Y'
            if 'XML_NAME' not in api_kwargs['config']:
                api_kwargs['config']['XML_NAME'] = os.path.join(self.log_path, 
                    '{0}.swarp.log.xml'.format(step_id))
        swarp = api.Astromatic(**api_kwargs)
        if frames is None:
            result = swarp.run(filenames)
        else:
            result = swarp.run_frames(filenames, 'SWarp', frames, False)
        return result
    
    def run_psfex(self, step_id, catalogs, api_kwargs={}):
        """
        Run PSFEx with a specified set of parameters.
        
        Parameters
        ----------
        step_id: str
            Unique identifier for the current step in the pipeline
        catalogs: str or list
            catalog filename (or list of catalog filenames) to use
        api_kwargs: dict
            Keyword arguements to pass to PSFEx
        
        Returns
        -------
        result: dict
            Result of the astromatic code execution. This will minimally contain a ``status``
            key, that indicates ``success`` or ``error``. Additional keys:
            - error_msg: str
                If there is an error and the user is storing the output or exporting XML metadata,
                ``error_msg`` will contain the error message generated by the code
            - output: str
                If ``store_output==True`` the output of the program execution is
                stored in the ``output`` value.
            - warnings: str
                If the WRITE_XML parameter is ``True`` then a table of warnings detected
                in the code is returned
        """
        if 'code' not in api_kwargs:
            api_kwargs['code'] = 'PSFEx'
        if 'cmd' not in api_kwargs and 'PSFEx' in self.build_paths:
            api_kwargs['cmd'] = self.build_paths['PSFEx']
        if 'temp_path' not in api_kwargs:
            api_kwargs['temp_path'] = self.temp_path
        if 'config' not in api_kwargs:
            api_kwargs['config'] = {}
        if 'PSF_DIR' not in api_kwargs['config']:
            api_kwargs['config']['PSF_DIR'] = self.temp_path
        if self.log_path is not None:
            if 'WRITE_XML' not in api_kwargs['config']:
                api_kwargs['config']['WRITE_XML'] = 'Y'
            if 'XML_NAME' not in api_kwargs['config']:
                api_kwargs['config']['XML_NAME'] = os.path.join(self.log_path, 
                    '{0}.psfex.log.xml'.format(step_id))
        psfex = api.Astromatic(**api_kwargs)
        result = psfex.run(catalogs)
        return result
     
    def add_step(self, func, tags, **kwargs):
        """
        Add a new `PipelineStep` to the pipeline
        
        Parameters
        ----------
        func: function or string
            If ``func`` is a string this should be the name of an astromatic code, otherwise
            ``func`` is a function to be run in the pipeline. All functions must return
            a dictionary with at a minimum a ``status`` key whose value is either
            ``success`` or ``error``.
        tags: list
            A list of tags used to identify the step. When running the pipeline the user
            can specify a set of conditions that will filter which steps are run (or not run)
            based on a set of specified tags
        kwargs: dict
            Keyword arguments passed to the ``func`` when the pipeline is run
        """
        if isinstance(func, string_types):
            if func in api.codes:
                if func == 'SExtractor':
                    func = self.run_sex
                elif func == 'SCAMP':
                    func = self.run_scamp
                elif func == 'PSFEx':
                    func = self.run_psfex
                elif func == 'SWarp':
                    func = self.run_swarp
                else:
                    raise PipelineError("You must either pass a function for the pipeline "
                        "to run or the name of an astromatic code, "
                        "'{0}' not recognized")
            else:
                raise PipelineError("You must either pass a function for the pipeline "
                    "to run or the name of an astromatic code")
        step_id = self.next_id
        self.next_id += 1
        self.steps.append(PipelineStep(
            func,
            step_id,
            tags,
            kwargs
        ))
            
    def run(self, run_tags=[], ignore_tags=[], pipeline_steps=None, run_name=None):
        """
        Run the pipeline given a list of PipelineSteps
        
        Parameters
        ----------
        run_tags: list
            Run all steps that have a tag listed in ``run_tags`` and not in ``ignore_tags``.
            If ``len(run_tags)==0`` then all of the steps are run that are not listed 
            in ignore tags.
        ignore_tags: list
            Ignore all steps that contain one of the tags in ``ignore_tags``.
        pipeline_steps: list of `PipelineStep` (optional)
            Instead of running the steps associated with a pipeline, the user can specify
            a set of steps to run. This can be useful if (for example) mulitple criteria
            are used to select steps to run and the user wants to perform these cuts in
            some other function to generate the necessary steps to run.
        run_name: str
            Name of the current run. When a pipeline is run, if a ``logpath`` has been
            specified then a copy of the pipline with a record of all warnings and
            steps run is saved in the ``logpath`` directory. A ``run_name`` can be specified
            to distinguish between different runs of the same pipeline with the same
            ``logpath``.
        """
        if pipeline_steps is None:
            pipeline_steps = self.steps
        
        # Filter steps to include steps with run_tags and exclude steps with ignore_tabs
        if self.run_steps is None:
            self.run_steps = [step for step in pipeline_steps if
                (len(run_tags) == 0 or any([tag in run_tags for tag in step.tags])) and
                not any([tag in ignore_tags for tag in step.tags])]
        # Set the path of the logfile for the current run
        dill_dump=False
        if self.log_path is not None:
            if run_name is None:
                logfile = os.path.join(self.log_path, 'pipeline.p')
            else:
                logfile = os.path.join(self.log_path, 'pipeline-{0}.p'.format(run_name))
            logger.info('Pipeline warnings will be stored in {0}'.format(logfile))
            # Save the pipeline in the log directory
            try:
                import dill
                dill_dump=True
                dill.dump(self, open(logfile, 'w'))
            except ImportError:
                import warnings
                warnings.warn('Pipeline requires "dill" to save log file')
        
        steps = self.run_steps[self.run_step_idx:]
        all_warnings = None
        for step in steps:
            logger.info('running step {0}: {1}'.format(step.step_id, step.tags))
            result = step.func(step.step_id, **step.func_kwargs)
            # Log any warnings and resave the log file in case the application crashes
            if('warnings' in result and result['warnings'] is not None and
                    len(result['warnings'])>0):
                from astropy.table import vstack
                warnings = result['warnings']
                warnings['filename'] = result['warnings'].meta['filename']
                warnings['step'] = step.step_id
                if all_warnings is None:
                    all_warnings = warnings
                else:
                    all_warnings = vstack([all_warnings, warnings])
                    # Some warning tables may have values not contained in other tables
                    # dill has problems loading pipelines with masked astropy tables
                    # so we fill the blank columns with a zero (usually frame in scamp)
                    all_warnings = all_warnings.filled(0)
            if dill_dump:
                # Save the pipeline in the log directory
                if all_warnings is not None and all_warnings.masked:
                    print 'in pipeline'
                    import IPython
                    IPython.embed()
                self.run_warnings = all_warnings
                dill.dump(self, open(logfile, 'w'))
            if result['status'] == 'error':
                result = {
                    'status': 'error',
                    'function_result': result,
                    'warnings': all_warnings,
                    'log': log
                }
                return result
            self.run_step_idx+=1
        
        result = {
            'status': 'success',
            'warnings': all_warnings
        }
        return result

class PipelineStep:
    """
    A single step in the pipeline. This takes a function and a set of tags and kwargs
    associated with it and stores them in the pipeline.
    """
    def __init__(self, func, step_id, tags=[], func_kwargs={}):
        """
        Initialize a PipelineStep object
        
        Parameters
        ----------
        func: function
            The function to be run. All functions must return a dictionary with at a 
            minimum a ``status`` key whose value is either ``success`` or ``error``.
        id: str
            Unique identifier for the step
        tags: list
            A list of tags used to identify the step. When running the pipeline the user
            can specify a set of conditions that will filter which steps are run (or not run)
            based on a set of specified tags
        func_kwargs: dict
            Keyword arguments passed to the ``func`` when the pipeline is run
        """
        self.func = func
        self.tags = tags
        self.step_id = step_id
        self.func_kwargs = func_kwargs